import getSocialText from '../getSocialText'
import getAttachmentText from '../getAttachmentText'
import getAttachmentMessage from '../getAttachmentMessage'

/**
 * Converts post content to text.
 * Removes `post-link`s and their autogenerated `inline-quotes`.
 * Can optionally ignore attachments (or skip them unless there's no text).
 * Can optionally exclude `quotes` and `inline-quote`s.
 * @param  {object} post
 * @param  {object} options — `{ softLimit, messages, excludeQuotes, ignoreAttachments, skipAttachments }`
 * @return {string}
 */
export default function getPostText(post, options = {}) {
	// Simple case optimization.
	if (typeof post.content === 'string') {
		return post.content
	}
	if (post.content) {
		// Concatenate post paragraphs' text.
		let text = ''
		let softLimit = options.softLimit
		for (const block of post.content) {
			let blockText = getContentText(block, softLimit, {
				...options,
				attachments: post.attachments
			})
			if (blockText) {
				blockText = blockText.trim()
			}
			if (!blockText) {
				continue
			}
			if (text) {
				text += '\n\n'
			}
			text += blockText
			if (softLimit !== undefined) {
				softLimit -= blockText.length - countOccurrences(blockText, '\n')
				if (softLimit <= 0) {
					break
				}
			}
		}
		if (text) {
			return text
		}
	}
	// If there're any attachments then fall back to attachment text.
	if (post.attachments && !options.ignoreAttachments) {
		for (const attachment of post.attachments) {
			if (getAttachmentText(attachment, options.messages)) {
				return getAttachmentText(attachment, options.messages)
			}
		}
		if (options.messages) {
			for (const attachment of post.attachments) {
				if (getAttachmentMessage(attachment, options.messages)) {
					return getAttachmentMessage(attachment, options.messages)
				}
			}
		}
	}
	return ''
}

export function getContentText(content, softLimit, options = {}) {
	if (typeof content === 'string') {
		return content
	}
	if (Array.isArray(content)) {
		let text = ''
		let i = 0
		while (i < content.length) {
			const part = content[i]
			const isStandalonePostLink = content[i].type === 'post-link' &&
				(i === 0 || content[i - 1] === '\n') &&
				(i === content.length - 1 || content[i + 1] === '\n')
			let partText
			if (isStandalonePostLink && !part.quote && !part.quotes) {
				// Ignore standalone post links without quote content.
				// (for example, hidden or deleted posts)
			} else {
				partText = getContentText(part, softLimit, options)
			}
			if (partText) {
				text += partText
				if (softLimit !== undefined) {
					softLimit -= partText.length - countOccurrences(partText, '\n')
					if (softLimit <= 0) {
						break
					}
				}
			} else {
				if (i + 1 < content.length) {
					// Skip the "new line" after the ignored post part.
					if (content[i + 1] === '\n') {
						i++
					}
				}
			}
			i++
		}
		// Some parts return empty text which means they're ignored
		// so there may be possibly some dangling "new line"s.
		// For example, if there was a quote in the beginning
		// and then some "new line"s and then some text
		// then such quote in the beginning would be ignored
		// resulting in dangling "new line"s.
		return text
			.replace(/^\n+/, '')
			.replace(/\n+$/, '')
	}
	const part = content
	const getContent = (content = part.content) => getContentText(content, softLimit, options)
	switch (part.type) {
		case 'quote':
			if (options.excludeQuotes) {
				return
			}
			if (part.source) {
				return `«${getContent()}» — ${part.source}`
			}
			return `«${getContent()}»`
		case 'inline-quote':
			if (options.excludeQuotes) {
				return
			}
			return `«${getContent()}»`
		case 'spoiler':
			// https://www.w3schools.com/charsets/ref_utf_block.asp
			// ░ LIGHT SHADE
			// ▒ MEDIUM SHADE
			// ▓ DARK SHADE
			// █ FULL BLOCK
			// Also add "line break" characters
			// because otherwise in iOS Safari it would overflow.
			return '░\u200b'.repeat(getContent().length)
		case 'post-link':
			if (options.excludePostQuotes || (part.quoteAutogenerated && options.excludeAutogeneratedPostQuotes)) {
				return
			}
			if (part.quotes) {
				return part.quotes.map(quote => `«${getContent(quote)}»`).join('\n')
			}
			return `«${getContent(part.quote)}»`
		case 'link':
			if (part.autogenerated) {
				return getHumanReadableLinkAddress(part.url)
			}
			return part.content
		case 'monospace':
			if (!part.inline && options.excludeCodeBlocks) {
				if (options.messages && options.messages.code) {
					return '(' + options.messages.code.toLowerCase() + ')'
				}
				return
			}
			return getContent()
		case 'attachment':
			if (options.ignoreAttachments || options.skipAttachments) {
				return
			}
			const attachment = options.attachments.find(_ => _.id === part.attachmentId)
			if (!attachment) {
				return
			}
			const text = getAttachmentText(attachment, options.messages)
			if (text) {
				return text
			}
			if (options.skipUntitledAttachments) {
				return
			}
			if (!options.messages) {
				return
			}
			return getAttachmentMessage(attachment, options.messages)
		default:
			return getContent()
	}
}

function getHumanReadableLinkAddress(url) {
	try {
		url = decodeURI(url)
	} catch (error) {
		// Sometimes throws "URIError: URI malformed".
		console.error(error)
	}
	return url
		// Remove `https://www.` in the beginning.
		.replace(/^https?:\/\/(www\.)?/, '')
		// Remove `/` in the end.
		.replace(/\/$/, '')
}

function countOccurrences(string, character) {
	let count = 0
	for (const char of string) {
		if (char === character) {
			count++
		}
	}
	return count
}